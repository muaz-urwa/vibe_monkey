<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Level 1 ‚Äî Find the Cat</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui; background:#0b1020; overscroll-behavior:none; touch-action:none; }
    .wrap { height: 100%; display:flex; align-items:center; justify-content:center; padding:16px; }
    canvas { background: linear-gradient(#14214a, #0b1020); border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.4); max-width:100%; height:auto; touch-action:none; }

    /* Mobile touch layer sits above canvas */
    .touch-ui{ position:fixed; inset:0; z-index:20; pointer-events:auto; background:transparent; touch-action:none; }
    .joy{ position:absolute; left:18px; bottom:18px; width:160px; height:160px; border-radius:999px;
      background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); }
    .joy .knob{ position:absolute; left:50%; top:50%; width:70px; height:70px; border-radius:999px;
      transform:translate(-50%,-50%); background:rgba(255,255,255,.16); border:1px solid rgba(255,255,255,.18); }
    .btn{ position:absolute; right:18px; bottom:32px; width:140px; height:72px; border-radius:18px;
      background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.16); color:rgba(255,255,255,.92);
      font:700 18px system-ui; }
    .left-stack{ position:absolute; left:18px; bottom:200px; display:flex; flex-direction:column; gap:10px; }
    .btn.small{ width:120px; height:48px; border-radius:14px; font-size:14px; }

    @media (pointer:fine){ .touch-ui{ display:none; } }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="960" height="540"></canvas>
  </div>

  <div class="touch-ui" id="touchUI" aria-hidden="true">
    <div class="joy" id="joy"><div class="knob" id="knob"></div></div>
    <button class="btn" id="dashBtn">DASH</button>
    <div class="left-stack">
      <button class="btn small" id="restartBtn">RESTART</button>
      <button class="btn small" id="newMazeBtn">NEW MAZE</button>
    </div>
  </div>

  <script type="module">
    import { getPlayer, playerImg, go } from "./common.js";

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;

    const playerName = getPlayer() || "Abia";
    const imgPlayer = new Image(); imgPlayer.src = playerImg(playerName);
    const imgCat = new Image(); imgCat.src = "character/cat.png";
    const imgDog = new Image(); imgDog.src = "character/dog.png";
    const imgMom = new Image(); imgMom.src = "character/mom.png";

    // ====== Tuning ======
    const GAME_TIME = 22;
    const R = 14;
    const DRAW_SIZE = 52;

    const PLAYER_SPEED = 300;
    const DASH_SPEED = 620;
    const DASH_DURATION = 0.12;
    const DASH_COOLDOWN = 1.45;

    const MOM_SPEED = 230;
    const DOG_SPEED = 150;
    const AI_RECALC = 0.18;

    const CAT_SPEED = 120;
    const CAT_RECALC = 0.9;

    const WIN_DIST = 26;
    const MOM_CATCH = 30;
    const DOG_CATCH_CAT = 28;

    // ====== Maze bounds/settings ======
    const bounds = { x: 28, y: 28, w: W-56, h: H-56 };
    const COLS = 14, ROWS = 8;
    const CELL = Math.floor(Math.min(bounds.w / COLS, bounds.h / ROWS));
    const WALL_T = 8;

    // ====== RNG ======
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }
    let seed = (Date.now() & 0xffffffff) >>> 0;
    let rnd = mulberry32(seed);

    // ====== Helpers ======
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const hypot = (x,y)=>Math.hypot(x,y);
    const norm = (x,y)=>{ const l=Math.hypot(x,y)||1; return {x:x/l,y:y/l}; };

    // ====== Maze grid ======
    let maze = [];
    let walls = [];

    function initMaze(){
      maze = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>({n:true,e:true,s:true,w:true,vis:false})));
    }
    function inGrid(x,y){ return x>=0 && y>=0 && x<COLS && y<ROWS; }

    function carveMazeDFS(){
      const stack = [];
      let cx = Math.floor(rnd()*COLS), cy = Math.floor(rnd()*ROWS);
      maze[cy][cx].vis = true;
      stack.push([cx,cy]);

      const dirs = [
        {dx:0, dy:-1, a:"n", b:"s"},
        {dx:1, dy:0,  a:"e", b:"w"},
        {dx:0, dy:1,  a:"s", b:"n"},
        {dx:-1,dy:0,  a:"w", b:"e"},
      ];

      while(stack.length){
        const [x,y] = stack[stack.length-1];
        const opts=[];
        for(const d of dirs){
          const nx=x+d.dx, ny=y+d.dy;
          if(inGrid(nx,ny) && !maze[ny][nx].vis) opts.push(d);
        }
        if(!opts.length){ stack.pop(); continue; }
        const d = opts[Math.floor(rnd()*opts.length)];
        const nx=x+d.dx, ny=y+d.dy;
        maze[y][x][d.a]=false; maze[ny][nx][d.b]=false;
        maze[ny][nx].vis=true;
        stack.push([nx,ny]);
      }

      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) maze[y][x].vis=false;
    }

    function knockOutRandomWalls(count){
      for(let i=0;i<count;i++){
        const x = Math.floor(rnd()*COLS), y = Math.floor(rnd()*ROWS);
        const c = maze[y][x];
        const options = [];
        if (y>0) options.push(["n", 0,-1, "s"]);
        if (x<COLS-1) options.push(["e", 1,0, "w"]);
        if (y<ROWS-1) options.push(["s", 0,1, "n"]);
        if (x>0) options.push(["w", -1,0, "e"]);
        if (!options.length) continue;
        const [a,dx,dy,b] = options[Math.floor(rnd()*options.length)];
        const nx=x+dx, ny=y+dy;
        c[a]=false; maze[ny][nx][b]=false;
      }
    }

    function cellToWorld(cx,cy){ return { x: bounds.x + cx*CELL, y: bounds.y + cy*CELL }; }
    function cellCenter(cx,cy){ const p=cellToWorld(cx,cy); return { x: p.x + CELL/2, y: p.y + CELL/2 }; }
    function worldToCell(x,y){
      const cx = clamp(Math.floor((x-bounds.x)/CELL),0,COLS-1);
      const cy = clamp(Math.floor((y-bounds.y)/CELL),0,ROWS-1);
      return [cx,cy];
    }

    function rebuildWalls(){
      walls = [];
      // outer bounds
      walls.push({x:bounds.x, y:bounds.y, w:COLS*CELL, h:WALL_T});
      walls.push({x:bounds.x, y:bounds.y + ROWS*CELL - WALL_T, w:COLS*CELL, h:WALL_T});
      walls.push({x:bounds.x, y:bounds.y, w:WALL_T, h:ROWS*CELL});
      walls.push({x:bounds.x + COLS*CELL - WALL_T, y:bounds.y, w:WALL_T, h:ROWS*CELL});
      // cell walls
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          const c=maze[y][x], p=cellToWorld(x,y);
          if(c.n) walls.push({x:p.x, y:p.y, w:CELL, h:WALL_T});
          if(c.w) walls.push({x:p.x, y:p.y, w:WALL_T, h:CELL});
          if(y===ROWS-1 && c.s) walls.push({x:p.x, y:p.y + CELL - WALL_T, w:CELL, h:WALL_T});
          if(x===COLS-1 && c.e) walls.push({x:p.x + CELL - WALL_T, y:p.y, w:WALL_T, h:CELL});
        }
      }
    }

    function neighbors(cx,cy){
      const c = maze[cy][cx];
      const out=[];
      if(!c.n && inGrid(cx,cy-1)) out.push([cx,cy-1]);
      if(!c.e && inGrid(cx+1,cy)) out.push([cx+1,cy]);
      if(!c.s && inGrid(cx,cy+1)) out.push([cx,cy+1]);
      if(!c.w && inGrid(cx-1,cy)) out.push([cx-1,cy]);
      return out;
    }

    // ====== Collision circle vs rect ======
    function circleVsRect(ent, r){
      const closestX = clamp(ent.x, r.x, r.x + r.w);
      const closestY = clamp(ent.y, r.y, r.y + r.h);
      const dx = ent.x - closestX;
      const dy = ent.y - closestY;
      const d = Math.hypot(dx,dy);
      if(d === 0) return {hit:true, nx:1, ny:0, pen:ent.r};
      if(d < ent.r) return {hit:true, nx:dx/d, ny:dy/d, pen:ent.r - d};
      return {hit:false, nx:0, ny:0, pen:0};
    }
    function resolve(ent, rect){
      const c = circleVsRect(ent, rect);
      if(!c.hit) return false;
      ent.x += c.nx*c.pen;
      ent.y += c.ny*c.pen;
      const vn = ent.vx*c.nx + ent.vy*c.ny;
      if(vn < 0){
        ent.vx -= vn*c.nx;
        ent.vy -= vn*c.ny;
      }
      return true;
    }

    // ====== BFS AI ======
    function bfsFrom(startCx, startCy){
      const dist = Array.from({length:ROWS}, ()=>Array(COLS).fill(-1));
      const q=[];
      dist[startCy][startCx]=0;
      q.push([startCx,startCy]);
      for(let i=0;i<q.length;i++){
        const [x,y]=q[i];
        const d = dist[y][x];
        for(const [nx,ny] of neighbors(x,y)){
          if(dist[ny][nx]===-1){
            dist[ny][nx]=d+1;
            q.push([nx,ny]);
          }
        }
      }
      return dist;
    }
    function nextStepToward(distField, cx, cy){
      const here = distField[cy][cx];
      if(here <= 0) return [cx,cy];
      let best=[cx,cy], bestD=here;
      for(const [nx,ny] of neighbors(cx,cy)){
        const d = distField[ny][nx];
        if(d !== -1 && d < bestD){ bestD=d; best=[nx,ny]; }
      }
      return best;
    }

    // ====== Entities ======
    const player = { x:0,y:0,r:R,vx:0,vy:0, dashLeft:0, dashCd:0 };
    const cat    = { x:0,y:0,r:R,vx:0,vy:0, aiT:0, target:null };
    const mom    = { x:0,y:0,r:R,vx:0,vy:0, aiT:0, dist:null, next:null };
    const dog    = { x:0,y:0,r:R,vx:0,vy:0, aiT:0, dist:null, next:null };

    const State = { START:"start", PLAY:"play", WIN:"win", LOSE:"lose" };
    let state = State.START;
    let timeLeft = GAME_TIME;
    let navigating = false;

    // ====== Overlay DOM ======
    let overlayDiv=null;
    function overlay(html){
      ctx.save(); ctx.fillStyle="rgba(0,0,0,0.55)"; ctx.fillRect(0,0,W,H); ctx.restore();
      if(!overlayDiv){
        overlayDiv=document.createElement("div");
        overlayDiv.style.position="fixed";
        overlayDiv.style.inset="0";
        overlayDiv.style.display="flex";
        overlayDiv.style.alignItems="center";
        overlayDiv.style.justifyContent="center";
        overlayDiv.style.pointerEvents="none";
        overlayDiv.style.padding="24px";
        overlayDiv.style.zIndex="10";
        document.body.appendChild(overlayDiv);
      }
      overlayDiv.style.display="flex";
      overlayDiv.innerHTML = `
        <div style="pointer-events:none;max-width:720px;width:100%;
          background:rgba(15,18,30,0.86);border:1px solid rgba(255,255,255,0.14);
          box-shadow:0 20px 80px rgba(0,0,0,0.5);border-radius:18px;
          padding:26px 22px;color:rgba(255,255,255,0.95);text-align:center;">
          ${html}
        </div>`;
    }
    function hideOverlay(){
      if(!overlayDiv) return;
      overlayDiv.style.display="none";
      overlayDiv.innerHTML="";
    }

    function buildMaze(){
      initMaze();
      carveMazeDFS();
      knockOutRandomWalls(22);
      rebuildWalls();
    }

    function resetPositions(){
      const p = cellCenter(1, ROWS-2);
      const c = cellCenter(COLS-2, 1);
      const m = cellCenter(Math.floor(COLS/2), Math.floor(ROWS/2));
      const d = cellCenter(COLS-2, ROWS-2);

      Object.assign(player, {x:p.x,y:p.y,vx:0,vy:0,dashLeft:0,dashCd:0});
      Object.assign(cat,    {x:c.x,y:c.y,vx:0,vy:0,aiT:0,target:null});
      Object.assign(mom,    {x:m.x,y:m.y,vx:0,vy:0,aiT:0,dist:null,next:null});
      Object.assign(dog,    {x:d.x,y:d.y,vx:0,vy:0,aiT:0,dist:null,next:null});
    }

    function startGame(){
      if(state !== State.START) return;
      state = State.PLAY;
      timeLeft = GAME_TIME;
      hideOverlay();
    }

    function lose(text){
      if(navigating) return;
      navigating = true;
      state = State.LOSE;
      localStorage.setItem("specialMessage", text);
      setTimeout(()=>go("loser.html"), 50);
    }

    function win(){
      if(navigating) return;
      navigating = true;
      state = State.WIN;
      localStorage.setItem("specialMessage", "");
      setTimeout(()=>go("level1_complete.html"), 50);
    }

    // ====== Input (keyboard + touch joystick) ======
    const keys = new Set();
    window.addEventListener("keydown",(e)=>{
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
      keys.add(e.key.toLowerCase());
      if(state===State.START && (e.key==="Enter" || e.key===" ")) startGame();
    }, {passive:false});
    window.addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()));
    const isDown = (k)=>keys.has(k);

    let touchMove={x:0,y:0};
    let touchDash=false;

    const joy=document.getElementById("joy");
    const knob=document.getElementById("knob");
    const dashBtn=document.getElementById("dashBtn");
    const restartBtn=document.getElementById("restartBtn");
    const newMazeBtn=document.getElementById("newMazeBtn");
    const touchUI=document.getElementById("touchUI");

    function setKnob(nx,ny){
      const max=55;
      knob.style.transform = `translate(${nx*max}px, ${ny*max}px) translate(-50%,-50%)`;
    }

    let joyActiveId=null, joyCenter=null;
    joy.addEventListener("pointerdown",(e)=>{
      joyActiveId=e.pointerId;
      joy.setPointerCapture(e.pointerId);
      const r=joy.getBoundingClientRect();
      joyCenter={x:r.left+r.width/2,y:r.top+r.height/2};
      e.preventDefault();
    },{passive:false});
    joy.addEventListener("pointermove",(e)=>{
      if(e.pointerId!==joyActiveId || !joyCenter) return;
      const dx=e.clientX-joyCenter.x, dy=e.clientY-joyCenter.y;
      const max=60;
      const nx=clamp(dx/max,-1,1), ny=clamp(dy/max,-1,1);
      touchMove={x:nx,y:ny};
      setKnob(nx,ny);
      e.preventDefault();
    },{passive:false});
    function joyUp(){
      joyActiveId=null; joyCenter=null;
      touchMove={x:0,y:0}; setKnob(0,0);
    }
    joy.addEventListener("pointerup",joyUp);
    joy.addEventListener("pointercancel",joyUp);

    dashBtn.addEventListener("pointerdown",(e)=>{touchDash=true; e.preventDefault();},{passive:false});
    dashBtn.addEventListener("pointerup",(e)=>{touchDash=false; e.preventDefault();},{passive:false});
    dashBtn.addEventListener("pointercancel",(e)=>{touchDash=false; e.preventDefault();},{passive:false});

    restartBtn.onclick = ()=>{ buildMaze(); resetPositions(); state=State.START; navigating=false; };
    newMazeBtn.onclick  = ()=>{ seed=(Date.now()&0xffffffff)>>>0; rnd=mulberry32(seed); buildMaze(); resetPositions(); state=State.START; navigating=false; };

    // Desktop: canvas tap starts
    canvas.addEventListener("pointerdown", ()=>{
      if(state===State.START) startGame();
    }, {passive:true});

    // ‚úÖ PHONE FIX (works on iPhone/Android):
    // On phones, the touch UI overlay covers the canvas, so taps NEVER reach the canvas.
    // Start the game on ANY tap anywhere on the overlay (including on joystick/dash/buttons).
    function startFromAnyTap(){
      if(state === State.START) startGame();
    }
    touchUI.addEventListener("pointerdown", startFromAnyTap, {passive:true});
    touchUI.addEventListener("touchstart", startFromAnyTap, {passive:true});
    touchUI.addEventListener("mousedown", startFromAnyTap, {passive:true});

    // ====== Update ======
    function update(dt){
      if(state !== State.PLAY) return;

      timeLeft -= dt;
      if(timeLeft <= 0){
        lose("Time‚Äôs up!");
        return;
      }

      let ix=0, iy=0;
      if(isDown("arrowleft")||isDown("a")) ix-=1;
      if(isDown("arrowright")||isDown("d")) ix+=1;
      if(isDown("arrowup")||isDown("w")) iy-=1;
      if(isDown("arrowdown")||isDown("s")) iy+=1;

      if(Math.abs(touchMove.x)>0.05 || Math.abs(touchMove.y)>0.05){
        ix=touchMove.x; iy=touchMove.y;
      }

      const d = norm(ix,iy);
      let speed = PLAYER_SPEED;

      player.dashCd = Math.max(0, player.dashCd - dt);
      if(player.dashLeft > 0){
        player.dashLeft = Math.max(0, player.dashLeft - dt);
        speed = DASH_SPEED;
      } else if((isDown(" ") || touchDash) && player.dashCd<=0 && (ix!==0 || iy!==0)){
        player.dashLeft = DASH_DURATION;
        player.dashCd = DASH_COOLDOWN;
        speed = DASH_SPEED;
      }

      player.vx = d.x*speed;
      player.vy = d.y*speed;
      player.x += player.vx*dt;
      player.y += player.vy*dt;
      for(const w of walls) resolve(player,w);

      // Cat wander
      cat.aiT -= dt;
      if(cat.aiT <= 0 || !cat.target){
        cat.aiT = CAT_RECALC;
        const [ccx, ccy] = worldToCell(cat.x, cat.y);
        const neigh = neighbors(ccx, ccy);
        if(neigh.length){
          const pick = neigh[Math.floor(rnd()*neigh.length)];
          cat.target = cellCenter(pick[0], pick[1]);
        } else {
          cat.target = cellCenter(ccx, ccy);
        }
      }
      if(cat.target){
        const dx = cat.target.x - cat.x;
        const dy = cat.target.y - cat.y;
        const dist = Math.hypot(dx, dy);
        if(dist < 6){
          cat.vx = 0; cat.vy = 0;
        } else {
          const v = norm(dx, dy);
          cat.vx = v.x * CAT_SPEED;
          cat.vy = v.y * CAT_SPEED;
          cat.x += cat.vx * dt;
          cat.y += cat.vy * dt;
          for(let i=0;i<2;i++) for(const w of walls) resolve(cat,w);
        }
      }

      // Mom chase player
      mom.aiT -= dt;
      if(mom.aiT <= 0){
        mom.aiT = AI_RECALC;
        const [pcx,pcy]=worldToCell(player.x,player.y);
        mom.dist = bfsFrom(pcx,pcy);
      }
      if(mom.dist){
        const [mcx,mcy]=worldToCell(mom.x,mom.y);
        mom.next = nextStepToward(mom.dist, mcx, mcy);
        const t = cellCenter(mom.next[0], mom.next[1]);
        const mv = norm(t.x-mom.x, t.y-mom.y);
        mom.vx = mv.x*MOM_SPEED;
        mom.vy = mv.y*MOM_SPEED;
        mom.x += mom.vx*dt;
        mom.y += mom.vy*dt;
        for(let i=0;i<2;i++) for(const w of walls) resolve(mom,w);
      }

      // Dog chase cat
      dog.aiT -= dt;
      if(dog.aiT <= 0){
        dog.aiT = AI_RECALC;
        const [ccx,ccy]=worldToCell(cat.x,cat.y);
        dog.dist = bfsFrom(ccx,ccy);
      }
      if(dog.dist){
        const [dcx,dcy]=worldToCell(dog.x,dog.y);
        dog.next = nextStepToward(dog.dist, dcx, dcy);
        const t = cellCenter(dog.next[0], dog.next[1]);
        const dv = norm(t.x-dog.x, t.y-dog.y);
        dog.vx = dv.x*DOG_SPEED;
        dog.vy = dv.y*DOG_SPEED;
        dog.x += dog.vx*dt;
        dog.y += dog.vy*dt;
        for(let i=0;i<2;i++) for(const w of walls) resolve(dog,w);
      }

      // Checks
      if(hypot(mom.x-player.x, mom.y-player.y) <= MOM_CATCH){ lose("Mom caught you!"); return; }
      if(hypot(dog.x-cat.x, dog.y-cat.y) <= DOG_CATCH_CAT){ lose("Dog caught the cat!"); return; }
      if(hypot(player.x-cat.x, player.y-cat.y) <= WIN_DIST){ win(); return; }
    }

    // ====== Draw ======
    function drawEntity(ent, img, fallback){
      ctx.save();
      ctx.translate(ent.x, ent.y);

      ctx.fillStyle="rgba(0,0,0,0.25)";
      ctx.beginPath(); ctx.ellipse(0, ent.r+16, 18, 8, 0, 0, Math.PI*2); ctx.fill();

      ctx.save();
      ctx.beginPath(); ctx.arc(0,0,ent.r+12,0,Math.PI*2); ctx.clip();
      if(img && img.complete && img.naturalWidth>0){
        ctx.drawImage(img, -DRAW_SIZE/2, -DRAW_SIZE/2, DRAW_SIZE, DRAW_SIZE);
      } else {
        ctx.fillStyle="rgba(255,255,255,0.18)";
        ctx.beginPath(); ctx.arc(0,0,ent.r+12,0,Math.PI*2); ctx.fill();
        ctx.fillStyle="rgba(255,255,255,0.85)";
        ctx.font="28px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(fallback, 0, 1);
      }
      ctx.restore();

      ctx.strokeStyle="rgba(255,255,255,0.35)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(0,0,ent.r+12,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    function roundRect(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function draw(){
      ctx.clearRect(0,0,W,H);

      // border
      ctx.save();
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      ctx.lineWidth=2;
      ctx.beginPath();
      roundRect(bounds.x, bounds.y, COLS*CELL, ROWS*CELL, 16);
      ctx.stroke();
      ctx.restore();

      // walls
      for(const w of walls){
        ctx.save();
        ctx.fillStyle="rgba(255,255,255,0.12)";
        ctx.strokeStyle="rgba(255,255,255,0.18)";
        ctx.lineWidth=1;
        ctx.beginPath();
        roundRect(w.x,w.y,w.w,w.h,8);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      }

      // HUD
      ctx.save();
      ctx.fillStyle="rgba(255,255,255,0.92)";
      ctx.font="600 18px system-ui";
      ctx.fillText(`Level 1 ‚Äî Find the Cat`, 26, 24);
      ctx.fillText(`Time: ${Math.ceil(timeLeft)}s`, 26, 46);
      const cd = player.dashCd>0 ? player.dashCd.toFixed(1) : "ready";
      ctx.fillText(`Dash: ${cd}`, 170, 46);
      ctx.restore();

      drawEntity(mom, imgMom, "üë©");
      drawEntity(dog, imgDog, "üê∂");
      drawEntity(cat, imgCat, "üê±");
      drawEntity(player, imgPlayer, "üôÇ");

      if(state === State.START){
        overlay(`
          <h1 style="margin:.1em 0 0;font-size:44px">Level 1: Find the Cat</h1>
          <p style="margin:.6em 0 1em;font-size:18px;opacity:.9">
            Reach the cat before the timer ends.<br/>
            If Mom catches you OR the dog catches the cat, you lose.
          </p>
          <p style="margin:0;font-size:16px;opacity:.85">
            Move: WASD / Arrows ‚Ä¢ Dash: Space ‚Ä¢ Tap to start
          </p>
        `);
      } else {
        hideOverlay();
      }
    }

    let lastT=performance.now();
    function frame(t){
      const dt=Math.min(0.033,(t-lastT)/1000);
      lastT=t;
      update(dt);
      draw();
      requestAnimationFrame(frame);
    }

    buildMaze();
    resetPositions();
    requestAnimationFrame(frame);
  </script>
</body>
</html>
